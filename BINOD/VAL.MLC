*******************************************************
*                   REFERENCES                        *
*******************************************************
*        MODULE - VAL                                 *
*                 INPUT TREE LEVEL DATA VALIDATION    *
*        SYSTEM - PC/370 CROSS ASSEMBLER              *
*        AUTHOR - BERNABE LLOVERA                     *
*        DATE   - SEPTEMBER 1995                      *
*******************************************************
*                                                     *
*     PROGRAM ENTRY POINT: VAL                        *
*     OTHER ENTRIES:                                  *
*        MENUTAB  = MENU TREE LEVEL TABLE             *
*        TREETAB  = 2ND LEVEL TREE TABLE (SIDE MOVE)  *
*        SYSNAME  = SYSTEM TREE MENU NAME             *
*                                                     *
*     EXTERNAL REFERENCES:                            *
*        SCRSYSNM = SYSTEM DESCRIPTION FROM TREE FILE *
*        TREELEV  = WINDOWS TREE LEVEL FLD LOCATION   *
*        SUBSNAM  = SYSTEM NAME                       *
*        SYSTEMCD = SYSTEM NAME                       *
*                                                     *
*******************************************************
*        ENTRY VAL,MENUTAB,TREETAB,SYSNAME
*        ENTRY VAL
*        EXTRN SCRSYSNM,TREELEV,SYSTEMCD,SUBSNAM
*
*        PRINT NOGEN
*******************************************************
*                                                     *
*        MAINLINE PROGRAM                             *
*                                                     *
*******************************************************
VAL      CSECT
         ENTRY
*******************************************************
*          SETING BASE REGISTERS                      *
*******************************************************
XX3      STM   R14,R12,12(R13) SAVE IN CALLERS SAVE AREA
         LR    R12,R15
         USING XX3,R12,R11
         LA    R15,XX3SAV1     GET PROGRAMS SAVE AREA ADDR
         ST    R13,4(R15)      SAVE CALLERS SAVE AREA ADDR
         ST    R15,8(R13)      SAVE PROGRAMS SAVE AREA IN CALLERS AREA
         LR    R13,R15         GET PROGRAMS SAVE AREA ADDR
         L     R11,XX3SAV2     LOAD 2ND BASE REG
         B     AROUND          SKIP SAVE AREA FLD
XX3SAV1  DS    18F             RETURN SAVE REGS AREA
XX3SAV2  DC    A(XX3+4096)     2ND BASE REG ADDR
         DC    CL12'<<VAL>>'   DUMP PROGRAM ID
AROUND   DS    0H
*******************************************************
         ST    R1,R1SAVE          SAVE IT FROM OPEN
*        OPEN  (INDCB,,PRINTS,(OUTPUT))
         OPEN  INDCB
*
         OI    INDCB+10,X'08'     TURN TRASLATE ASCII TO EBDCIC
         MVC   RETCODE,=F'0'      RESET ERROR RETURN CODE
         XC    LEVLEV1,LEVLEV1    RESET ACTUAL TREE LEVEL TO 0'S
         L     R1,R1SAVE          GET PARAMETER LIST ADDR
         L     R3,0(R1)           POINT TO 1ST PARAMETER
         CLC   0(8,R3),=CL8' '    IS IT A BACKWARD REQUEST?
         BNE   DOFORWR            NO, GO FORWARD
*
         L     R2,SUBSYSCN        GET SUB SYSTEM OCURRECE COUNT
         C     R2,=F'1'           ARE WE AT THE TOP OF THE TABLE?
         BH    SYSOK1             NO, BACKOFF ONE SYSTEM
         MVC   RETCODE,=F'1'      SHOW BACKWARD ERROR ON RETURN
         B     ENDIN              EXIT
SYSOK1   DS    0H
         BCTR  R2,0               DECREMENT TABLE OCURRENCE
         ST    R2,SUBSYSCN        PUT IT BACK IN COUNT FIELD
         BCTR  R2,0               DECREMENT TABLE OCURRENCE
         MH    R2,=H'18'          DISPLACEMENT INTO TABLE
         LA    R2,SUBSYST(R2)     POINT TO SUBSYSTEM TAB ARG
         MVC   SYSNAME(8),0(R2)   GET OLD SYSTEM NAME
         L     R3,=V(SYSTEMCD)    WINDOWS SYSTEM NAME
         MVC   0(8,R3),SYSNAME    SET ACTUAL SYSTEM NAME
         L     R3,=V(TREELEV)     GET WINDOWS TREE LEVEL FLD ADDR
         MVC   0(10,R3),26(R2)    SET ACTUAL TREE LEVEL LOCATION
         BAL   R14,SCANLEV        ERASE LAST LEVEL TO AVOID LOOP
         MVC   LEVLEV1,26(R2)     SAVE ACTUAL TREE LEVEL FOR COMPARE
         B     SYSCLEAR           CONTINUE CLEARING SW
*
DOFORWR  DS    0H
         MVC   SYSNAME(8),0(R3)   SAVE CALLERS SYSTEM NAME
         L     R2,SUBSYSCN        GET SUB SYSTEM OCURRECE COUNT
         C     R2,=F'19'          ARE WE OVER 20 LEVELS?
         BNH   SYSOK2             NO, SYSTEM OK
         MVC   RETCODE,=F'2'      SHOW FORWARD ERROR ON RETURN
         B     ENDIN              EXIT
SYSOK2   DS    0H
         LA    R3,1(R2)           BUMP OCURRECE TO SHOW UPDATE
         ST    R3,SUBSYSCN        SAVE COUNT
         MH    R2,=H'18'          DISPLACEMENT INTO TABLE
         LA    R2,SUBSYST(R2)     POINT TO SUBSYSTEM TAB ARG
         MVC   0(8,R2),SYSNAME    SAVE NEW SYSTEM NAME IN TABLE
         L     R3,=V(TREELEV)     GET WINDOWS TREE LEVEL FLD ADDR
         MVC   8(10,R2),0(R3)     SAVE ACTUAL TREE LEVEL LOCATION
         L     R3,=V(SUBSNAM)     WINDOWS SYSTEM NAME
         MVC   0(8,R3),SYSNAME    SET ACTUAL SYSTEM NAME
         L     R3,=V(SYSTEMCD)    WINDOWS SYSTEM NAME
         MVC   0(8,R3),SYSNAME    SET ACTUAL SYSTEM NAME
*
SYSCLEAR DS    0H
         MVI   SWNAMER,X'00'      RESET NAME RECORD FOUND SWITCH
*
GETNEXTN DS    0H
         BAL   R14,READ           READ A RECORD
         CLC   =C'NAME=',IN1      NAME RECORD FOUND?
         BNE   GETNEXTN           NO, GO GET NEXT RECORD
         CLC   IN1+5(8),SYSNAME   IS THIS OUR MENU TREE?
         BNE   GETNEXTN           NO, TRY NEXT INPUT RECORD
         L     R2,=V(SCRSYSNM)    GET SYSTEM DESCR ADDR IN OUTSTR
         MVC   0(39,R2),IN1+14    MOVE SYSTEM DESCR TO SCR HEADDING
         MVI   SWNAMER,X'01'      SET NAME RECORD FOUND SWITCH
         BAL   R14,CLEAR          CLEAR WORKAREAS & RESET POINTERS
*
GETNXRC  DS    0H
         BAL   R14,READ           READ A RECORD
         CLC   =C'NAME=',IN1      NAME RECORD FOUND?
         BE    ENDIN              YES, END OF MENU TREE FOUND
         CLI   IN1COM,C'@'        ARE WE AT AN AT (LEVEL) SIGN?
         BNE   TRYTX              NO, TRY TEXT
*        CLI   IN1TYP,C'H'        IS THIS A HORIZONTAL MENU?
*        BE    DOHORLV            YES, DO HORIZONTAL LEVEL MENU
*        CLI   IN1TYP,C'V'        IS THIS A VERTICAL MENU?
*        BNE   GETNXRC            NO, TREAT AS IF COMMENTS BYPASS
DOHORLV  DS    0H
         BAL   R14,PROCLEV        YES, PROCESS THIS LEVEL
         B     GETNXRC            LOOP TO READING UNTIL END
TRYTX    DS    0H
         CLI   IN1COM,C'T'        ARE WE AT A TEXT RECORD?
         BNE   GETNXRC            NO, BYPASS RECORD AS IF COMMENTS
         CLI   HORZVERT,C'V'      ARE WE DOING A VERTICAL MENU?
         BNE   CHECKHR            NO, GO CHECK IF DOING HORIZONTAL
         BAL   R14,PROCVXTV       YES, PROCESS THIS VERTICAL MENU
         B     CHECKOT            NO, GO CHECK IF DOING OTHERWISE
CHECKHR  DS    0H
         CLI   HORZVERT,C'H'      ARE WE DOING A HORIZONTAL MENU?
         BNE   CHECKOT            NO, GO CHECK IF DOING OTHERWISE
         BAL   R14,PROCHXTH       YES, PROCESS THIS VERTICAL MENU
CHECKOT  DS    0H
         B     GETNXRC            LOOP TO READING UNTIL END
*
ENDIN    DS    0H
         CLC   RETCODE,=F'0'      ANY ERRORS ON MAINLINE?
         BNE   PROOK              YES, DON'T CHANGE ERR CODE
         CLI   SWNAMER,X'01'      NAME RECORD FOUND?
         BE    ENDTST             YES, NAME OK
         L     R2,SUBSYSCN        GET SUB SYSTEM OCURRECE COUNT
         BCTR  R2,0               DECREMENT SYSTEM TABLE OCCURRENCE
         ST    R2,SUBSYSCN        SET SUB SYSTEM OCURRECE COUNT
         BNE   PROERMS            GO SET MESSAGE ADDRESS
ENDTST   DS    0H
         CLI   ERRSWIT,X'00'      ANY ERRS DURING LAVEL TABLE PROC?
         BNE   PROERMS            YES, GO SET MESSAGE ADDRESS
         CLI   ERRSWIT1,X'00'     ANY ERRS DURING HOR/VETR TABLE PROC?
         BNE   PROERMS            YES, GO SET MESSAGE ADDRESS
         B     PROOK              NO, EVERYTHING OK
PROERMS  DS    0H
         MVC   LINE(47),ERRMSG2   GENERAL ERROR MESSAGE
         BAL   R14,PRINT          GO PRINT IT
         MVC   RETCODE,=A(ERRMSG2) RETURN MESSAGE ADDRESS
PROOK    DS    0H
*        CLOSE (INDCB,,PRINTS)
         CLOSE INDCB
*        L     R15,RETCODE        GET PROGRAM RETURN CODE
         EXIT  SAVE=YES,RC=RETCODE
*
*******************************************************
*     PROCHXTH: DO HORIZONTAL TEXT & CURSOR TABLES    *
*     ON ENTRY:                                       *
*     ON EXIT:                                        *
*******************************************************
PROCHXTH DS    0H
         ST    R14,SVTXH           PUSH RET ADDR
         STM   R1,R9,TXHRR         PUSH REGS
         NI    ERRSWIT1,X'00'      RESET ERROR SWITCH
         L     R1,LEVACADD         LAST LOCATION IN LEVEL TABLE
         USING LEV,R1              ADDRESS OUTPUT
         L     R10,TABACADD        LAST LOCATION IN MENU TABLE
         USING MEN,R10             ADDRESS OUTPUT
*
         CLI   SWLEVTX,X'00'       DID WE JUST PASS LEVEL PROC?
         BNE   PROCHNRC            NO, DON'T CALCULATE 1ST ROW/COL
         MVC   LEVMENU,TABACADD    UPDATE LEVEL MENU TABLE POINTER
         SR    R2,R2               ERASE FOR IC
         IC    R2,LEVBOX           GET TOP LEFT ROW
         BCTR  R2,0                DEBUMP TO USE ROUTINE BUMPING
         STC   R2,MENOPTR          SAVE AS IS
         STC   R2,MENOPTR1         SAVE AS IS FOR OPTNS ROW
         IC    R2,LEVBOX+1         GET TOP LEFT COLUMN
         BCTR  R2,0                MAKE IT RELATIVE TO ZERO
         STC   R2,MENOPTC          SAVE IT FOR MENU OPTIONS COLUMNS
         STC   R2,MENOPTC1         SAVE IT FOR 1ST OPTIONS COLUMN
         MVI   SWLEVTX,X'01'       SET TEXT PROCESSING SWITCH
         XC    OPTNCNT,OPTNCNT     RESET MENU OPTION COUNT
         LA    R4,IN1TEX           START OF STRING ADDRESS
         LA    R7,IN1+70           END OF STRING (COL 71)
         LA    R8,HORCURT          HORIZONTAL CURSOR TABLE ADDRESS
PROCHNRC DS    0H
*
         XR    R6,R6               RESET FOR IC
         CLI   LEVLEV1,X'00'       ARE WE TESTING LEVELS?
         ST    R6,SAVELVL          RESET LEVEL LENGTH
         BE    PROCHSK1            NO, LEAVE R6=0 FOR NORMAL INTENSITY
         L     R6,LASTLVL          GET LAST LEVEL LENGTH
         EX    R6,LEVCLC1          ACTUAL LEVEL PART OF CALLING?
         BE    PROCHSK0            YES, USE HI INTENSITY
         XR    R6,R6               RESET FOR IC
         ST    R6,SAVELVL          RESET LEVEL LENGTH
         B     PROCHSK1            USE NORMAL INTENSITY (R6=0)
PROCHSK0 DS    0H
         IC    R6,LEVLEV1+1(R6)    GET NEXT LEVEL FROM CALLING LEVEL
         ST    R6,SAVELVL          RESET LEVEL LENGTH
PROCHSK1 DS    0H
         LA    R5,1                COUNTER TO MATCH WITH NEXT LEV
         B     PROCHNR             SKIP READING THE 1ST TIME
*
LEVCLC1  CLC   LEVLEV1(*-*),LEVLEV COMPARE ACTUAL LEV WITH CALLING
*
*
PROCHXLP DS    0H                  DIFERENT TEXT LINE SCAN LOOP
         BAL   R14,READ            READ A RECORD
         CLI   IN1COM,C'T'         ARE WE AT A TEXT RECORD?
         BNE   PROCHCUR            NO, GO GENERATE CURSOR TABLE
*
PROCHNR  DS    0H
         SR    R2,R2               CALCULATE NEXT OPTION ROW
         IC    R2,MENOPTR          GET TOP LEFT ROW
         LA    R2,1(R2)            BUMP IT ONCE FOR NEXT ROW
         STC   R2,MENOPTR          SAVE IT FOR THIS OPTIONS ROW
*
PROCHSLP DS    0H                  SAME TEXT LINE SCAN LOOP
******** LA    R4,IN1TEX           START OF STRING ADDRESS
******** LA    R7,IN1+70           END OF STRING (COL 71)
         BAL   R14,SCANCOMM        SCAN TEXT TO EXTRACT OPTION
         LR    R4,R0               GET EFECTIVE START STR ADDR
         LTR   R15,R15             ANY LUCK?
         BNZ   PROCHXT             YES, DO TEXT
******** OI    ERRSWIT1,X'01'      SET NO TEXT ERR AT SW (** MAY BE **)
         B     PROCHXLP            GET NEXT TEXT LINE
*
PROCHXT  DS    0H
         L     R2,OPTNCNT          GET PRIOR MENU OPTION COUNT
         A     R2,=F'1'            BUMP COUNT
         ST    R2,OPTNCNT          UPDATE IT
*
         BCTR  R15,0               ADJUST FOR EX
         EX    R15,PROCHMVC        EXECUTE MOVE
*        LA    R3,IN1TEX(R15)      GET SET TO MOVE FLD END
*        MVC   0(4,R3),=X'40401D60' MOVE SCREEN FIELD END
*        LA    R15,4(R15)          COMPUTE TOTAL STRING LENGTH
         LA    R15,1(R15)          SET LENGTH BACK LIKE BEFORE EX
         STC   R15,MENLEN          STORE FOR TREE MANAGER
         B     PROCHNLN            SKIP EXECUTE OBJECT INSTRUCTION
*
PROCHMVC MVC   MENOPT(*-*),HORIZCM MOVE TEXT OUT
*
PROCHNLN DS    0H
         MVC   MENROW,MENOPTR      MOVE THIS OPTIONS ROW
         MVC   MENCOL,MENOPTC      MOVE THIS OPTIONS COLUMN
         SR    R2,R2               FIX FOR IC
         IC    R2,MENOPTC          GET COLUMN
         LA    R2,2(R15,R2)        UPDATE COLUMN POINTER PASSED TEXT
*
         C     R8,=A(HORCURTE)     HOR CUR TABLE CAPACITY EXAUSTED?
         BNL   PROCHNCT            YES, SKIP THIS OPTION CURSOR LOC
         MVC   0(1,R8),MENROW      MOVE ROW TO HORIZ CUR TAB
         STC   R2,1(R8)            MOVE COL TO HORIZ CUR TAB
         LA    R8,2(R8)            BUMP HORIZ CUR TAB POINTER
PROCHNCT DS    0H
         LA    R2,1(R2)            UPDATE COLUMN (+2+1 FOR CUR & ATT)
         STC   R2,MENOPTC          SAVE IT
         CR    R6,R5               IS THIS OUR ARGUMENT?
         BNE   PROCHNI             NO, USE NORMAL INTENSITY
         MVI   MENATT,X'E8'        YES, USE HI INTENSITY
         B     PROCHHI             GO ON WITH THE REST
PROCHNI  DS    0H
         MVI   MENATT,X'60'        USE NORMAL INTENSITY
PROCHHI  DS    0H
         LA    R5,1(R5)            BUMP POSITIVE ARG COUNTER
         LA    R4,1(R15,R4)        BUMP INPUT ADDRESS POINTER
         ST    R10,SAVFEND         SAVE FOR THE END TO MOVE MENLEN
         LA    R10,4(R15,R10)      BUMP MENU TABLE ADDRESS POINTER
         ST    R10,TABACADD        UPDATE LAST LOCATION IN MENU TABLE
         B     PROCHSLP            DO TILL NO MORE TEXT RECORDS
*
PROCHCUR DS    0H
         L     R2,OPTNCNT          GET MENU OPTION COUNT
         STC   R2,LEVLEN           MOVE TO LEVEL TABLE ARGUMENT
         MVI   0(R10),X'00'        INDICATE END OF MENU TABLE
         LA    R10,1(R10)          BUMP MENU TABLE ADDRESS BY 1
         ST    R10,TABACADD        UPDATE LAST LOCATION IN MENU TABLE
*
         STCM  R10,B'1111',LEVCURO UPDATE LEVEL CURSOR TABLE PIONTER
*
*******************************************************
*     GENERATE OUTPUT CURSOR TABLE                    *
*******************************************************
         DROP  R10
         USING CUR,R10             ADDRESS CURSOR TABLE OUTPUT
         LA    R8,HORCURT          HORIZONTAL CURSOR TABLE ADDRESS
*
         ST    R10,FIRSTCU1        INCERT CUR LOC AT CUR TAB
         L     R6,SAVELVL          GET LEVEL LENGTH
         LA    R5,1                COUNTER TO MATCH WITH NEXT LEV
*
PROCHLP1 DS    0H
         MVC   CURROW,0(R8)        POKE ROW LOCTAION
         SR    R2,R2               FIX FOR IC
         IC    R2,1(R8)            GET COLUMN FROM HORIZONTAL TABLE
         BCTR  R2,0                DECREMENT FOR ATTR FLD LOCATION
         STC   R2,CURCOL           MOVE THIS OPTIONS COLUMN
         STC   R2,1(R8)            UPDATE COLUMN IN HORIZONTAL TABLE
         CR    R6,R5               IS THIS OUR ARGUMENT?
         BNE   PROCHLCL            NO, LEAVE 1ST CURSOR LOCATION
         ST    R10,FIRSTCU1        SAVE LOC FOR INCERT CUR COMMAND
PROCHLCL DS    0H
         LA    R5,1(R5)            BUMP POSITIVE ARG COUNTER
         MVI   CURATT,X'40'        MOVE ATTRIBUTE
         MVI   CURLEN,X'03'        3 FIXED BYTES LENGTH  *************
         MVI   CURFLD,X'40'        CURSOR FIELD          * DUMMY CMD *
         MVI   CURCMD,X'1D'        SET ATTRIBUTE COMMAND * DUMMY CMD *
         MVI   CUREND,X'60'        SET FIELD END ATTR    * DUMMY CMD *
         LA    R8,2(R8)            BUMP HOR CUR TAB ADDR *************
         LA    R10,7(R10)          BUMP CURSOR TAB ARG ADDR POINTER
         ST    R10,TABACADD        UPDATE LAST LOCATION IN MENU TABLE
         CLI   0(R8),X'00'         ARE WE AT INPUT TABLE END?
         BNE   PROCHLP1            NO, LOOP
         DROP  R10
         USING INCUR,R10           ADDRESS INCERT CURSOR COMMAND
         L     R2,FIRSTCU1         HORIZONTAL CURSOR TABLE ADDRESS
*        LA    R2,HORCURT          HORIZONTAL CURSOR TABLE ADDRESS
         MVC   INCURRW(1),0(R2)    MOVE CURSOR ROW
         MVC   INCURCL(1),1(R2)    MOVE CURSOR COLUMN
         MVI   INCURAT,X'40'       MOVE CURSOR ATTRIBUTE (HI-LITE)
         MVI   INCURLN,X'01'       MOVE CURSOR LEN 01
         MVI   INCURCM,X'13'       MOVE INCERT CURSOR COMMAND
         MVI   INCUREN,X'00'       MOVE CURSOR TABLE DELIMITER
         LA    R10,6(R10)          BUMP CURSOR TAB ARG ADDR POINTER
         ST    R10,TABACADD        UPDATE LAST LOCATION IN MENU TABLE
*
         STCM  R10,B'1111',LEVCURT CURSOR INPUT TEST TABLE ADDRESS
*
         LA    R8,HORCURT          HORIZONTAL CURSOR TABLE ADDRESS
PROCHLP2 DS    0H
         MVC   ROW,0(R8)           POKE ROW LOCTAION
         SR    R2,R2               FIX FOR IC
         IC    R2,1(R8)            GET COLUMN FROM HORIZONTAL TABLE
         LA    R2,1(R2)            INCREMENT FOR CUR LOC TEST
         STC   R2,COL              MOVE THIS OPTIONS COLUMN
         BAL   R14,TWELVE          GENERATE 3270 ADDRESS CODE
         MVC   0(2,R10),CHABUFAD   POKE TOP RITE CORNER ADDRRESS
*
*        SR    R2,R2               FOR IC
*        IC    R2,0(0,R10)         GET ROW BACK
*        BCTR  R2,0                DEBUMP FOR COMPATIBILITY WITH 3270
*        STC   R2,0(0,R10)         RESTORE BACK
*
         LA    R8,2(R8)            BUMP INPUT TABLE PIONTER
         LA    R10,2(R10)          BUMP TABLE OUTPUT PIONTER
         CLI   0(R8),X'00'         ARE WE AT INPUT TABLE END?
         BNE   PROCHLP2            NO, LOOP
         MVI   0(R10),X'00'        POKE DELIMITER
         LA    R10,1(R10)          BUMP CURSOR TAB ARG ADDR POINTER
         ST    R10,TABACADD        UPDATE LAST LOCATION IN MENU TABLE
*        MVC   LEVBOX,=F'0'        ERASE HORIZONTAL COORDINATES
         MVI   LEVLIM,X'00'        MOVE LEVEL DELIMITER JUST IN CASE
*
PROCHEX  DS    0H
         DROP  R10
         DROP  R1
         LM    R1,R9,TXHRR         PUSH REGS
         L     R14,SVTXH           PUSH RET ADDR
         BR    R14
*
SAVFEND  DS    F                   LAST MENU TABLE ARG START ADDR *
*
*******************************************************
*     PROCVXTV: DO VERTICAL TEXT & CURSOR TABLES      *
*     ON ENTRY:                                       *
*     ON EXIT:                                        *
*******************************************************
PROCVXTV DS    0H
         ST    R14,SVTXV           PUSH RET ADDR
         STM   R1,R9,TXVRR         PUSH REGS
         NI    ERRSWIT1,X'00'      RESET ERROR SWITCH
         L     R1,LEVACADD         LAST LOCATION IN LEVEL TABLE
         USING LEV,R1              ADDRESS OUTPUT
         L     R10,TABACADD        LAST LOCATION IN MENU TABLE
         USING MEN,R10             ADDRESS OUTPUT
*
         CLI   SWLEVTX,X'00'       DID WE JUST PASS LEVEL PROC?
         BNE   PROCVNRC            NO, DON'T CALCULATE 1ST ROW/COL
         MVC   LEVMENU,TABACADD    UPDATE LEVEL MENU TABLE POINTER
         SR    R2,R2               ERASE FOR IC
         IC    R2,LEVBOX           GET TOP LEFT ROW
         STC   R2,MENOPTR          SAVE AS IS TO BUMP IT FOR EACH OPTN
         STC   R2,MENOPTR1         SAVE AS IS FOR 1ST OPTN ROW
         IC    R2,LEVBOX+1         GET TOP LEFT COLUMN
         LA    R2,1(R2)            BUMP IT TWICE FOR INITIAL LOC
         STC   R2,MENOPTC          SAVE IT FOR MENU OPTIONS COLUMNS
         STC   R2,MENOPTC1         SAVE IT FOR 1ST OPTIONS COLUMN
         MVI   SWLEVTX,X'01'       SET TEXT PROCESSING SWITCH
         XC    OPTNCNT,OPTNCNT     RESET MENU OPTION COUNT
         MVI   MAXOPTLN,X'00'      RESET WIDEST TEXT LEN BUFF
PROCVNRC DS    0H
*
         XR    R6,R6               RESET FOR IC
         ST    R6,SAVELVL          RESET LEVEL LENGTH
         CLI   LEVLEV1,X'00'       ARE WE TESTING LEVELS?
         BE    PROCVSK1            NO, LEAVE R6=0 FOR NORMAL INTENSITY
         L     R6,LASTLVL          GET LAST LEVEL LENGTH
         EX    R6,LEVCLC           ACTUAL LEVEL PART OF CALLING?
         BE    PROCVSK0            YES, USE HI INTENSITY
         XR    R6,R6               RESET FOR IC
         ST    R6,SAVELVL          RESET LEVEL LENGTH
         B     PROCVSK1            USE NORMAL INTENSITY (R6=0)
PROCVSK0 DS    0H
         IC    R6,LEVLEV1+1(R6)    GET NEXT LEVEL FROM CALLING LEVEL
         ST    R6,SAVELVL          SAVE LEVEL LENGTH
PROCVSK1 DS    0H
         LA    R5,1                COUNTER TO MATCH WITH NEXT LEV
         B     PROCVNR             SKIP READING THE 1ST TIME
*
LEVCLC   CLC   LEVLEV1(*-*),LEVLEV COMPARE ACTUAL LEV WITH CALLING
*
PROCVXLP DS    0H
         BAL   R14,READ           READ A RECORD
         CLI   IN1COM,C'T'        ARE WE AT A TEXT RECORD?
         BNE   PROCVCUR           NO, GO GENERATE CURSOR TABLE
*
PROCVNR  DS    0H
         L     R2,OPTNCNT          GET PRIOR MENU OPTION COUNT
         A     R2,=F'1'            BUMP COUNT
         ST    R2,OPTNCNT          UPDATE IT
*
         SR    R2,R2               CALCULATE NEXT OPTION ROW
         IC    R2,MENOPTR          GET TOP LEFT ROW
         LA    R2,1(R2)            BUMP IT ONCE FOR NEXT ROW
         STC   R2,MENOPTR          SAVE IT FOR THIS OPTIONS ROW
*
         LA    R7,IN1TEX           GET STRING START ADDR
         LA    R4,IN1+70           GET STR END FOR RITE TRIM
         BAL   R14,RITNBL          DO RITE TRIM
         LTR   R15,R15             ANY LUCK?
         BNZ   PROCVXT             YES, DO TEXT
         OI    ERRSWIT1,X'01'      SET NO TEXT ERR AT SW
         B     PROCVEX             EXIT
PROCVXT  DS    0H
         BCTR  R15,0               ADJUST FOR EX
         EX    R15,PROCVMVC        EXECUTE MOVE
         LA    R3,MENOPT(R15)      GET SET TO MOVE FLD END
         MVC   1(2,R3),=X'1D60'    MOVE SCREEN FIELD END
         LA    R15,1(R15)          SET LENGTH BACK LIKE BEFORE EX
         STC   R15,OPTLEN1         STRING LENGTH W/O FLD END
         LA    R15,2(R15)          COMPUTE TOTAL STRING LENGTH
         STC   R15,MENLEN          STORE FOR TREE MANAGER
         CLC   MAXOPTLN,OPTLEN1    IS OPT LENGTH > THAN THE ONE BEFORE?
         BNL   PROCVNLN            NO, SKIP SAVING IT
         MVC   MAXOPTLN,OPTLEN1    KEEP TRACK OF THE WIDEST TEXT
         B     PROCVNLN            SKIP EXECUTE INSTRUCTION
*
PROCVMVC MVC   MENOPT(*-*),IN1TEX  MOVE TEXT OUT
OPTLEN1  DC    X'00'               OUTPUT LENGTH W/O FIELD END
*
PROCVNLN DS   0H
         MVC   MENROW,MENOPTR      MOVE THIS OPTIONS ROW
         MVC   MENCOL,MENOPTC      MOVE THIS OPTIONS COLUMN
         CR    R6,R5               IS THIS OUR ARGUMENT?
         BNE   PROCVNI             NO, USE NORMAL INTENSITY
         MVI   MENATT,X'E8'        YES, USE HI INTENSITY
         B     PROCVHI             GO ON WITH THE REST
PROCVNI  DS    0H
         MVI   MENATT,X'60'        USE NORMAL INTENSITY
PROCVHI  DS    0H
         LA    R5,1(R5)            BUMP POSITIVE ARG COUNTER
         LA    R10,4(R15,R10)      BUMP MENU TABLE ADDRESS POINTER
         ST    R10,TABACADD        UPDATE LAST LOCATION IN MENU TABLE
         B     PROCVXLP            DO TILL NO MORE TEXT RECORDS
*
PROCVCUR DS    0H
         L     R2,OPTNCNT          GET MENU OPTION COUNT
         STC   R2,LEVLEN           MOVE TO LEVEL TABLE ARGUMENT
         MVI   0(R10),X'00'        INDICATE END OF MENU TABLE
         LA    R10,1(R10)          BUMP MENU TABLE ADDRESS POINTER BY 1
         ST    R10,TABACADD        UPDATE LAST LOCATION IN MENU TABLE
*
         STCM  R10,B'1111',LEVCURO UPDATE LEVEL CURSOR TABLE PIONTER
*
*******************************************************
*     GENERATE OUTPUT CURSOR TABLE                    *
*******************************************************
         DROP  R10
         USING CUR,R10             ADDRESS CURSOR TABLE OUTPUT
         SR    R3,R3               CALCULATE OPTIONS CURSOR COLUMN
         IC    R3,MENOPTC1         GET SAVED TOP LEFT COLUMN
         SR    R2,R2               CALCULATE NEXT OPTION ROW
         IC    R2,MAXOPTLN         GET WIDEST OPTION TEXT LEN FOUND
         LA    R3,1(R2,R3)         LEFT COLUMN + TEXT LENGTH + 1
         STC   R3,MENOPTC1         SAVE OPTIONS CURSOR COLUMN
         IC    R2,MENOPTR1         GET TOP LEFT ROW
         L     R3,OPTNCNT          GET MENU OPTION COUNT
         ST    R10,FIRSTCU         INCERT CUR LOC AT CUR TAB
         ST    R10,FIRSTCU1        INCERT CUR LOC AT CUR TAB
         LA    R5,1                COUNTER TO MATCH WITH NEXT LEV
         L     R6,SAVELVL          GET PRIOR LEVEL LENGTH
PROCVLP1 DS   0H
         LA    R2,1(R2)            BUMP FOR NEXT ROW
         STC   R2,CURROW           POKE ROW LOCATION
         MVC   CURCOL,MENOPTC1     MOVE THIS OPTIONS COLUMN
         CR    R6,R5               IS THIS OUR ARGUMENT?
         BNE   PROCVLCL            NO, LEAVE INITIAL CURSOR LOCATION
         ST    R10,FIRSTCU1        SAVE LOC FOR INCERT CUR COMMAND
PROCVLCL DS    0H
         LA    R5,1(R5)            BUMP POSITIVE ARG COUNTER
         MVI   CURATT,X'40'        USE NORMAL INTENSITY
         MVI   CURLEN,X'03'        3 FIXED BYTES LENGTH
         MVI   CURFLD,X'40'        CURSOR FIELD
         MVI   CURCMD,X'1D'        SET ATTRIBUTE COMMAND
         MVI   CUREND,X'60'        SET FIELD END ATTRIBUTE
         LA    R10,7(R10)          BUMP CURS TAB ARG ADDR POINTER BY 7
         ST    R10,TABACADD        UPDATE LAST LOCATION IN MENU TABLE
         BCT   R3,PROCVLP1         DO IT TILL R3=0
         DROP  R10
         USING INCUR,R10           ADDRESS INCERT CURSOR COMMAND
         L     R2,FIRSTCU1         INCERT CUR LOC AT CUR TAB
         MVC   INCURRW(1),0(R2)    MOVE CURSOR ROW
         MVC   INCURCL(1),1(R2)    MOVE CURSOR COLUMN
         MVI   INCURAT,X'40'       MOVE CURSOR ATTRIBUTE (HI-LITE)
         MVI   INCURLN,X'01'       MOVE CURSOR LEN 01
         MVI   INCURCM,X'13'       MOVE INCERT CURSOR COMMAND
         MVI   INCUREN,X'00'       MOVE CURSOR TABLE DELIMITER
         LA    R10,6(R10)          BUMP CURSOR TAB ARG ADDR POINTER
         ST    R10,TABACADD        UPDATE LAST LOCATION IN MENU TABLE
*
         STCM  R10,B'1111',LEVCURT CURSOR INPUT TEST TABLE ADDRESS
         L     R3,OPTNCNT          GET MENU OPTION COUNT
         L     R2,FIRSTCU          INCERT CUR LOC AT CUR TAB
         SR    R5,R5               RESET FOR IC
         IC    R5,1(R2)            GET CURSOR COLUMN FROM TABLE
         LA    R5,1(R5)            ADJUST 1 FOR FIELD LOCATION
         SR    R4,R4               FIX FOR IC
         IC    R4,0(R2)            GET 1ST ROW
         BCTR  R4,0                DEBUMP TO USE BUMPING IN LOOP
PROCVLP2 DS   0H
         LA    R4,1(R4)            BUMP FOR NEXT ROW
         STC   R4,ROW              POKE ROW LOCATION
         STC   R5,COL              POKE COLUMN LOCATION
         BAL   R14,TWELVE          GENERATE 3270 ADDRESS CODE
         MVC   0(2,R10),CHABUFAD   POKE TOP RITE CORNER ADDRRESS
*
*        SR    R2,R2               FOR IC
*        IC    R2,0(0,R10)         GET ROW BACK
*        BCTR  R2,0                DEBUMP FOR COMPATIBILITY WITH 3270
*        STC   R2,0(0,R10)         RESTORE BACK
*
         LA    R10,2(R10)          BUMP TABLE OUTPUT PIONTER
         BCT   R3,PROCVLP2         DO IT TILL R3=0
         MVI   0(R10),X'00'        POKE DELIMITER
         LA    R10,1(R10)          BUMP CURSOR TAB ARG ADDR POINTER
         ST    R10,TABACADD        UPDATE LAST LOCATION IN MENU TABLE
         MVI   LEVLIM,X'00'        MOVE LEVEL DELIMITER JUST IN CASE
*
PROCVEX  DS    0H
         DROP  R10
         DROP  R1
         LM    R1,R9,TXVRR         PUSH REGS
         L     R14,SVTXV           PUSH RET ADDR
         BR    R14
*
*******************************************************
*     PROCLEV: GENERATE MENU TREE LEVEL TABLE         *
*     ON ENTRY:                                       *
*     ON EXIT:                                        *
*******************************************************
PROCLEV  DS    0H
         ST    R14,SVLEV           PUSH RET ADDR
         STM   R1,R9,LEVRR         PUSH REGS
         NI    ERRSWIT,X'00'       RESET ERROR SWITCH
         MVI   SWLEVTX,X'00'       RESET JUST PASSED LEVEL PROC SWITCH
         L     R1,LEVACADD         LAST LOCATION IN LEVEL TABLE
         CLI   SWLEVEL,X'00'       IS THIS THE 1ST TIME THRU?
         BE    PROCNBUM            YES, DON'T BUMP LEVEL TABLE ADDR
         LA    R1,LEVL(R1)         BUMP FOR NEXT LEVEL
         ST    R1,LEVACADD         UPDATE LAST LOCATION IN LEVEL TABLE
PROCNBUM DS    0H
         MVI   SWLEVEL,X'01'       NO 1ST TIME THRU
         USING LEV,R1              ADDRESS OUTPUT
         OC    IN1,=CL80' '        TURN LEVEL DATA TO UPPER CASE
*
*******************************************************
*     LEVEL NUMBER GENERATION                         *
*******************************************************
         MVN   COMPLEV,IN1LEV      MOVE NUMBERS TO TEST FOR NUMERICS
         CLC   COMPLEV,IN1LEV      IS ZONE PART THE SAME?
         BE    PRONUM              YES, INPUT LEVEL NUMERIC
         OI    ERRSWIT,X'01'       SET NOT NUM LEVEL ERR AT SW
*        B     PROEX               & EXIT
PRONUM   DS    0H
         LA    R2,IN1LEV           INPUT COUPLE OF NUM CHARS ADDR
         LA    R3,LEVLEV           OUTPUT SINGLE CHAR ADDR
         LA    R4,10               LOOP NEGATIVE COUNT
         LA    R5,0                LOOP POSITIVE COUNT
PROSHRLP DS    0H
         BAL   R14,SHRINK          SHRINK 2 NUMBERS IN 1 & MOVE
         CLI   0(R3),X'00'         IS THIS THE LAST ACTIVE LEVEL?
         BE    PROCLZE             YES, THIS IS A ZERO LEVEL
         ST    R5,LASTLVL          SAVE NON ZERO LEVEL CODE LEN
PROCLZE  DS    0H
         LA    R2,2(R2)            BUMP INPUT ADDR
         LA    R3,1(R3)            BUMP OUTPUT ADDR
         LA    R5,1(R5)            BUMP LEVEL LENGTH COUNTER
         BCT   R4,PROSHRLP         DO 10 LEVEL CHARS CONVERTION
*
         CLC   LEVLEV,LASTLEV      IS IT A VALID HIER LEVEL?
         BH    PROOKLV             YES, PROCEED
         OI    ERRSWIT,X'02'       NO, SET LEVEL OUT OF SEQ ERR AT SW
*        B     PROEX               & EXIT
PROOKLV  DS    0H
         MVC   LASTLEV,LEVLEV      UPDATE PROCESSED LEVEL
*
*******************************************************
*     BOX COORDINATES GENERATION                      *
*******************************************************
         MVN   COMPLEV(2),IN1TOP   MOVE NUMBERS TO TEST FOR NUMERICS
         CLC   COMPLEV(2),IN1TOP   IS ZONE PART THE SAME?
         BE    PRONUM1             YES, INPUT CHARS NUMERIC
         OI    ERRSWIT,X'04'       SET NOT NUM COORD ERR AT SW
*        B     PROEX               & EXIT
PRONUM1  DS    0H
         MVN   COMPLEV(2),IN1LFT   MOVE NUMBERS TO TEST FOR NUMERICS
         CLC   COMPLEV(2),IN1LFT   IS ZONE PART THE SAME?
         BE    PRONUM2             YES, INPUT CHARS NUMERIC
         OI    ERRSWIT,X'04'       SET NOT NUM COORD ERR AT SW
*        B     PROEX               & EXIT
PRONUM2  DS    0H
         MVN   COMPLEV(2),IN1BOT   MOVE NUMBERS TO TEST FOR NUMERICS
         CLC   COMPLEV(2),IN1BOT   IS ZONE PART THE SAME?
         BE    PRONUM3             YES, INPUT CHARS NUMERIC
         OI    ERRSWIT,X'04'       SET NOT NUM COORD ERR AT SW
*        B     PROEX               & EXIT
PRONUM3  DS    0H
         MVN   COMPLEV(2),IN1RIT   MOVE NUMBERS TO TEST FOR NUMERICS
         CLC   COMPLEV(2),IN1RIT   IS ZONE PART THE SAME?
         BE    PRONUM4             YES, INPUT CHARS NUMERIC
         OI    ERRSWIT,X'04'       SET NOT NUM COORD ERR AT SW
*        B     PROEX               & EXIT
PRONUM4  DS    0H
*
         LA    R2,IN1TOP           INPUT COUPLE OF NUM CHARS ADDR
         LA    R3,LEVBOX           OUTPUT SINGLE CHAR ADDR
         BAL   R14,SHRINK          SHRINK 2 NUMBERS IN 1 & MOVE
         CLI   LEVBOX,24           IS IT A VALID ROW?
         BNH   PROROK              YES, ROW OK
         OI    ERRSWIT,X'08'       SET INVALID ROW ERR AT SW
*        B     PROEX               & EXIT
*
PROROK   DS    0H
         LA    R2,IN1LFT           INPUT COUPLE OF NUM CHARS ADDR
         LA    R3,LEVBOX+1         OUTPUT SINGLE CHAR ADDR
         BAL   R14,SHRINK          SHRINK 2 NUMBERS IN 1 & MOVE
         CLI   LEVBOX+1,80         IS IT A VALID COLUMN?
         BNH   PROCOK              YES, COLUMN OK
         OI    ERRSWIT,X'10'       SET INVALID COL ERR AT SW
*        B     PROEX               & EXIT
*
PROCOK   DS    0H
         LA    R2,IN1BOT           INPUT COUPLE OF NUM CHARS ADDR
         LA    R3,LEVBOX+2         OUTPUT SINGLE CHAR ADDR
         BAL   R14,SHRINK          SHRINK 2 NUMBERS IN 1 & MOVE
         CLI   LEVBOX+2,24         IS IT A VALID ROW?
         BNH   PROROK1             YES, ROW OK
         OI    ERRSWIT,X'08'       SET INVALID ROW ERR AT SW
*        B     PROEX               & EXIT
*
PROROK1  DS    0H
         LA    R2,IN1RIT           INPUT COUPLE OF NUM CHARS ADDR
         LA    R3,LEVBOX+3         OUTPUT SINGLE CHAR ADDR
         BAL   R14,SHRINK          SHRINK 2 NUMBERS IN 1 & MOVE
         CLI   LEVBOX+3,80         IS IT A VALID COLUMN?
         BNH   PROCOK1             YES, COLUMN OK
         OI    ERRSWIT,X'10'       SET INVALID COL ERR AT SW
*        B     PROEX               & EXIT
*
PROCOK1  DS    0H
*        MVC   COORDCMP(2),IN1TOP   MOVE COORD TO DO ONE TEST
*        MVC   COORDCMP+2(2),IN1LFT
*        MVC   COORDCMP+4(2),IN1BOT
*        MVC   COORDCMP+6(2),IN1RIT
*        CLC   COORDCMP(8),=CL8'00000000' COORDS ALL ZERO?
*        BE    PROOKOR             YES, IGNORE VALIDATION
         CLI   IN1TYP,C'H'         ARE WE DOING HORIZONTAL?
         BE    PROOKOR             YES, ORIENTATION OK
         CLC   IN1BOT,IN1TOP       IS BOT GREATER THAN TOP?
         BH    PROOKOR             YES, ORIENTATION OK
         OI    ERRSWIT,X'20'       SET INVALID BOX ORIENT ERR AT SW
         CLC   IN1RIT,IN1LFT       IS RITE GREATER THAN LEFT?
         BH    PROOKOR             YES, BOX ORIENTATION OK
         OI    ERRSWIT,X'20'       SET INVALID BOX ORIENT ERR AT SW
PROOKOR  DS    0H
*
         CLI   IN1TYP,C'H'         IS IT A HORIZONTAL MENU?
         BE    PROTYOK             YES, MOVE TYPE
         CLI   IN1TYP,C'V'         IS IT A VERTICAL MENU?
         BE    PROTYOK             YES, MOVE TYPE
         CLI   IN1TYP,C'P'         IS IT A PROCESS?
         BE    PROTYOK             YES, MOVE TYPE
         CLI   IN1TYP,C'S'         IS IT A SYSTEM MENU?
         BE    PROTYOK             YES, MOVE TYPE
         OI    ERRSWIT,X'40'       NO, SET INVALID TYPE ERR AT SW
         B     PROSKNM             DON'T MOVE TYPE NOR NAME
PROTYOK  DS    0H
         MVC   HORZVERT,IN1TYP     MOVE H=HORIZ V=VERT P=PROC S=SYS
         MVC   LEVMOP,IN1TYP       MOVE H=HORIZ V=VERT P=PROC S=SYS
         CLI   LEVMOP,C'P'         IS IT A PROCESS?
         BE    PROTYOK1            YES, MOVE NAME
         CLI   LEVMOP,C'S'         IS IT A SYSTEM?
         BNE   PROSKNM             NO, SKIP MOVING NAME
PROTYOK1 DS    0H
         MVC   LEVCURO(8),IN1NAM      MOVE NAME IF P=PROC OR S=SYS
PROSKNM  DS    0H
*
PROEX    DS    0H
         DROP  R1
         LM    R1,R9,LEVRR         PUSH REGS
         L     R14,SVLEV           PUSH RET ADDR
         BR    R14
*
*******************************************************
*     SHRINK: CONVERTS TWO CHAR BYTES INTO ONE & MOVE *
*     ON ENTRY: R2 = INPUT COUPLE OF BYTES            *
*               R3 = OUTPUT SINGLE BYTE               *
*     ON EXIT:  CHARACTERS MOVED TO OUTPUT SINGLE BT  *
*******************************************************
SHRINK   DS    0H
         ST    R14,SVSHR           PUSH RET ADDR
         STM   R1,R6,SHRRR         PUSH REGS
*
         NC    0(2,R2),=X'0F0F'   RESET ZONES TO 0
         SR    R5,R5              FIX FOR IC
         IC    R5,0(R2)           GET 1ST NUM CHAR
         LR    R6,R5              GET A COPY FOR COMPUTE
         MH    R6,=H'10'          SHIFT TO THE TENTH
         IC    R5,1(R2)           GET 2ND NUM CHAR
         AR    R6,R5              GET TENTH & UNITS
         STC   R6,0(R3)           STORE SHRUNK DIGITS
*
         LM    R1,R6,SHRRR         POP REGS
         L     R14,SVSHR           POP RET ADDR
         BR    R14
*
*******************************************************
*     SCANLEV:  SCANS INPUT LEVEL CODE                *
*     ON ENTRY: SAME REGS AS LFTSCN                   *
*               R4 = START LOCATION ADDRESS           *
*     ON EXIT:  R15 = 0 = NO TEXT FOUND / END ADDRESS *
*               R0 = STRING START ADDRESS             *
*******************************************************
SCANLEV  DS    0H
         ST    R14,SVSLL            PUSH RET ADDR
         STM   R1,R9,SLLRR          PUSH REGS
         L     R4,=V(TREELEV)       STRING START (CALLING LEVEL)
         LA    R7,10(R4)            STRING LIMIT FOR SCAN
         LA    R3,=X'00'            VALUE ADDREESS
         LA    R2,1                 VALUE LENGTH
         BAL   R14,LFTSCN           SCAN FOR X'00'
         LTR   R15,R15              ANY LUCK?
         BZ    SCANLEVN             NO, ERASE LAST POSITION
         LR    R2,R0                SWITCH REGS
         BCTR  R2,0                 DECREMENT TO POKE X'00'
         MVI   0(R2),X'00'          POKE 00 TO TAKE A MENU OFF
         B     SCANLEVX             EXIT
SCANLEVN DS    0H
         L     R4,=V(TREELEV)       STRING START (CALLING LEVEL)
         MVI   9(R4),X'00'          ERASE LAST LEVEL LOCATION
SCANLEVX DS    0H
         LM    R1,R9,SLLRR          POP REGS
         L     R14,SVSLL            POP RET ADDR
         BR    R14
*
*******************************************************
*     SCANCOMM: SCANS INPUT COMMANDS                  *
*     ON ENTRY: SAME REGS AS LFTSCN                   *
*               R4 = START LOCATION ADDRESS           *
*     ON EXIT:  R15 = 0 = NO TEXT FOUND / END ADDRESS *
*               R0 = STRING START ADDRESS             *
*******************************************************
SCANCOMM DS    0H
         ST    R14,SVSCC           PUSH RET ADDR
         STM   R1,R9,SCCRR         PUSH REGS
         MVC   HORIZCM,HORIZCM-1   CLEAR OUTPUT TEXT FIELD
*
         LA    R2,1                GET VALUE LENGTH
         LA    R3,=C' '            ADDRESS OF VALUE
******** LA    R4,IN1+2            START OF STRING
******** LA    R7,68(R4)           END OF STRING (COL 71)
         LA    R8,HORIZCM          NO OUTPUT TABLE ADDRESS
         LA    R9,1                MAXIMUM INPUT LABELS
*
SCCLP    DS    0H
         LR    R5,R4               SAVE STR START ADDR
         BAL   R14,LFTSCN          SEARCH FOR A SPACE
         LR    R4,R0               BUMP START POINTER
         LR    R6,R4               SAVE ADDRESS POINTER
         SR    R6,R5               CALCULATE PARM LENGTH
         LTR   R6,R6               IS IT A DOBBLE SPACE?
         BNZ   SCCNON              NO, GO ON
         LA    R4,1(R4)            YES, BUMP INPUT POINTER
         B     SCCLP               AND FORGET IT
*
SCCNON   DS    0H
         LTR   R8,R8               ARE WE DOING ANY OUTPUT?
         BZ    SCCNOMVC            NO, SKIP OUTPUT
*
         BCTR  R6,0                ADJUST FOR EX
         EX    R6,SCCMVC           STRING DATA UP CONTIGUOUSLY
*        EX    R6,SCCOC            CHANGE DATA TO UPPER CASE
         LA    R8,1(R6,R8)         BUMP OUTPUT STRING
         B     SCCNOMVC            GO BUMP & LOOP
*
SCCNOMVC DS    0H
         LTR   R15,R15             ANY LUCK?
         BZ    SCCNEX              NO, EXIT SCAN
         LA    R15,1(R6)           RETURN TEXT LENGTH
         LR    R0,R5               RETURN TEXT START ADDRESS
         LA    R4,1(R4)            BUMP INPUT POINTER
         BCT   R9,SCCLP            ROLL IT FOR MAX INPUT TIMES
*
SCCNEX   DS    0H
         LM    R1,R9,SCCRR         POP REGS
         L     R14,SVSCC           POP RET ADDR
         BR    R14
*
SCCMVC   MVC   0(*-*,R8),0(R5)     MOVE PARAMTERS
SCCOC    OC    0(*-*,R8),=CL80' '  SET UPPER CASE (OR WITH X'40')
*
*******************************************************
*     LFTSCN -  SCAN VALUE FROM LEFT TO RIGHT         *
*     ON ENTRY: R14 = RETURN ADDR                     *
*               R7  = END OF STRING                   *
*               R4  = START OF STRING                 *
*               R3  = ADDRESS OF VALUE TO SCAN        *
*               R2  = LENGTH OF VALUE TO SCAN         *
*     ON EXIT:  R15 = ZERO = NOT FOUND                *
*               R0  = LAST ADDRESS TESTED             *
*******************************************************
LFTSCN   DS    0H
         ST    R14,SVLFT       PUSH RET ADDR
         STM   R1,R9,LFTRR     PUSH REGS
******** LA    R7,STREND       END OF STRING
******** LA    R4,STRSTART     START OF STRING
******** LA    R3,=C'SCAN'     ADDRESS OF VALUE
******** LA    R2,4            LENGTH OF VALUE
         BCTR  R2,0            DEBUMP FOR EX
         LR    R5,R4           ALSO R5 FOR COMPUTE
         LA    R6,1            STEP BUMP
LFTLP    DS    0H
         EX    R2,LFTCLC       IS IT THE VALUE?
         BE    LFTEX           YES, EXIT
         BXLE  R4,R6,LFTLP     DO WHILE (R4 + R6) <= R7
         SR    R15,R15         SHOW VALUE NOT FOUND
         B     LFTEX1          EXIT
LFTEX    DS    0H
         LR    R15,R4          SET OUTPUT PARAMETER
LFTEX1   DS    0H
         LR    R0,R4           SET LAST ADDRESS TESTED
         LM    R1,R9,LFTRR     POP REGS
         L     R14,SVLFT       POP RET ADDR
         BR    R14
*
LFTCLC   CLC   0(*-*,R4),0(R3)  COMPARE POS OF STRING WITH VALUE
*
*******************************************************
*     RITNBL - STRING 1ST RITE NON BLANK              *
*     ON ENTRY: R14 = RETURN ADDR                     *
*               R7  = START OF STRING                 *
*               R4  = END OF STRING                   *
*     ON EXIT:  R15 = ZERO = NOT FOUND / PLACE        *
*               R0  = 1ST NON BLANK POS ADDR          *
*******************************************************
RITNBL   DS    0H
         ST    R14,SVRIT       PUSH RET ADDR
         STM   R1,R7,RITRR     PUSH REGS
******** LA    R7,START        START OF STRING
         LR    R5,R7           ALSO R5 FOR COMPUTE
******** LA    R4,END          END OF STRING
         L     R6,=F'-1'       ARG LEN
RITLP    DS    0H
         CLI   0(R4),C' '      IS IT A BLANK?
         BNE   RITEX           NO, EXIT
         BXH   R4,R6,RITLP     DO WHILE (R4 + R6) > R7
         CLI   0(R4),C' '      IS IT A BLANK?
         BNE   RITEX           NO, EXIT
         SR    R15,R15         SHOW STRING EMPTY
         B     RITEX1          SKIP COMPUTE
RITEX    DS    0H
         LR    R0,R4           COMPUTE
         SR    R0,R5           EXACT
         A     R0,=F'1'        PLACE (LENGTH)
         LR    R15,R0          IN R15
RITEX1   DS    0H
         LR    R0,R4           SHOW LAST ADDRESS
         LM    R1,R7,RITRR     POP REGS
         L     R14,SVRIT       POP RET ADDR
         BR    R14
*
*******************************************************
*     PRINT: SUB-ROUTINE                              *
*******************************************************
PRINT    DS    0H
         ST    R14,SVPRI           PUSH RET ADDR
*        PUT   PRINTS,LINE
         MVI   LINE,C' '           SKIP LINE AND PRINT
         MVC   LINE+1(80),LINE     AND CLEAN BUFF
         L     R14,SVPRI           POP RET ADDR
         BR    R14
*
*******************************************************
*     READ: READ RECORD SUB-ROUTINE                   *
*******************************************************
READ     DS    0H
         ST    R14,SVREA           PUSH RET ADDR
         ST    R1,REARR            PUSH REGS
         GET   INDCB,IN1           READ A RECORD
         OI    IN1COM,C' '         TURN COMMAND (@ OR T) TO UPP CASE
         L     R1,INRECCN          GET PRIOR INPUT COUNT
         A     R1,=F'1'            BUMP COUNT
         ST    R1,INRECCN          UPDATE IT
         L     R1,REARR            POP REGS
         L     R14,SVREA           POP RET ADDR
         BR    R14
*
***********************************************************************
***                                                                 ***
*** SUBRUTINAS PARA EL MANEJO DE CARACTERES DE CONTROL 3270         ***
***                                                                 ***
*** CONVIERTE UN HALFWORD BINARIO QUE REPRESENTA EL "OFFSET"        ***
*** RELATIVO A LA POSICION 0 DE UN BUFFER 3270 A SU EQUIVALENTE     ***
*** DIRECCION 3270 (DOS CARACTERES)                                 ***
***   ENTRADA: R1 -> DIRECCION DE LA MEDIA PALABRA                  ***
***   SALIDA : R15-> DIRECCION DE LOS DOS CARACTERES                ***
***   INVOCACION:   BAL R14,ADDR3270                                ***
***********************************************************************
ADDR3270 DS    0H
         LH    2,0(1)           TAKE BINARY BUFFER ADDRESS
         STC   2,1(15)          SAVE IN TWO CHAR ANSWER FIELD +1
         SRL   2,6              TAKE FIRST PART
         STC   2,0(15)          SAVE IN TWO CHAR ANSWER FIELD +0
         NI    1(15),X'3F'      REMOVE EXCESS BITS
         TR    0(2,15),ADDBYTES TRANSFORM
         BR    14               RETURN
ADDBYTES DS    0H
         DC    X'40C1C2C3C4C5C6C7C8C94A4B'
         DC    X'4C4D4E4F50D1D2D3D4D5D6D7'
         DC    X'D8D95A5B5C5D5E5F6061E2E3'
         DC    X'E4E5E6E7E8E96A6B6C6D6E6F'
         DC    X'F0F1F2F3F4F5F6F7F8F97A7B'
         DC    X'7C7D7E7F'
*
***********************************************************************
*** OBTIENE LA DIRECCION DE BUFFER DADOS FILA, COLUMNA Y            ***
*** CANTIDAD DE COLUMNAS POR FILA.                                  ***
***   ENTRADA: R1 -> DIRECCION DE 4 BYTES CONTIGUOS ALINEADOS       ***
***                  |C|F|CF|  F:FILA; C:COLUMNA; CF:COLS/FILA      ***
***   SALIDA : R15-> DIRECCION DE BUFFER                            ***
***   INVOCACION:   BAL R14,BUFF327B                                ***
***********************************************************************
BUFF327B DS    0H
         SR    2,2               CLEAR WORK REG
         IC    2,0(1)            GET COLUMN
         BCTR  2,0               MINUS 1 FOR ADD
         SR    15,15             CLEAR WORK REG
         IC    15,1(1)           GET ROW
         BCTR  15,0              MINUS 1 FOR MULT
         MH    15,2(1)           TIMES NO OF COLS/ROW
         AR    15,2              RESULT IN R15
         BR    14                GOBACK
*
***********************************************************************
***                                                                 ***
*** COMBINES CALLS TO PREVIOUS SUB-ROUTINES IN ORDER TO OBTAIN      ***
*** BUFFER ADDRESS GIVEN ROW & COLUMN.                              ***
*** USAGE: BAL  R14,TWELVE                                          ***
***                                                                 ***
***********************************************************************
TWELVE   DS    0H
         ST    R14,SVTWE            PUSH RET ADDR
         STM   R1,R2,TWERR          PUSH REGS
*
         MVC   CHABUFAD(1),ROW      MOVE RAW ROW
         MVC   CHABUFAD+1(1),COL    MOVE RAW COLUMN
         B     TEMPEXIT             PC EXIT OF ROUTINE
*
         LA    R1,COL
         BAL   R14,BUFF327B         COMPUTE BINARY BUFFER ADDRESS
         STH   R15,BINBUFAD         SAVE IT
         LA    R1,BINBUFAD          PASS IT TO CONVERSION SUBROUTINE
         LA    R15,CHABUFAD         RESPONSE AREA
         BAL   R14,ADDR3270         GO GET IT
*
TEMPEXIT DS    0H
         LM    R1,R2,TWERR          POP REGS
         L     R14,SVTWE            POP RET ADDR
         BR    R14
*
*******************************************************
*    CLEAR - ERASE WORK AREAS                         *
*    ON ENTRY: R14 = RETURN ADDR                      *
*******************************************************
CLEAR    DS    0H
         ST    R14,SVCLE               PUSH RET ADDR
         STM   R1,R5,CLERR             PUSH
*
         MVC   LEVACADD,LEVSTADD       INITIALIZE LEVEL TABLE PTR
         MVC   TABACADD,TABSTADD       INITIALIZE OUTPUT TABLE PTR
*
         LA    R2,=X'00'               SOURCE ADDRESS
         LA    R3,1                    GET SOURCE FLD LEN
         L     R4,=A(DYNLEV)           LEVEL TABLE START ADDRESS
         L     R5,=A(DATAEND-DYNLEV)   GET DEST FLD LEN
         MVCL  R4,R2                   MOVE PADDING ZEROES
*
         L     R2,=A(TREETAB)          SIDEWISE TREETAB ADDR
         LA    R3,20                   LOOP COUNT
CLEALP   DS    0H
         NC    2(8,R2),=X'0000000000000000' RESET FROM 3RD LEV ON
         LA    R2,10(R2)               BUMP TREETAB ADDR
         BCT   R3,CLEALP               LOOP 20 TIMES
*
         XC    HORCURT(100),HORCURT    CLEAR HORIZ CURSOR TABLE
         XC    FIRSTCU,FIRSTCU         INCERT CURSOR LOC AT CUR TABLE
         XC    FIRSTCU1,FIRSTCU1       INCERT CURSOR LOC AT CUR TABLE
         XC    INRECCN,INRECCN         INPUT RECODR COUNT
         XC    LASTLEV,LASTLEV         LAST LEVEL PROCESSED (SEQ CHK)
         MVI   HORZVERT,C' '           MOVE H=HOR V=VER P=PRO S=SYS
         XC    OPTNCNT,OPTNCNT         MENU OPTIONS COUNT
         XC    MAXOPTLN,MAXOPTLN       MAXIMUM MENU OPTION LENGTH
         XC    SWLEVEL(7),SWLEVEL      LEV TABLE BUMPING SW PLUS
*
         LM    R1,R5,CLERR             POP
         L     R14,SVCLE               POP RET ADDR
         BR    R14
*
*******************************************************
*                                                     *
*    CONSTANTS AND VARIABLES                          *
*                                                     *
*******************************************************
         DS    0D
COL      DS    X          SCREEN COLUMN
ROW      DS    X          SCREEN ROW
COLROW   DC    H'80'      CULUMS PER ROW
CURSOR   DS    1H         CURSOR ADDRESS
COMMLEN  DS    1H         OUTPUT AREA LENGTH
BINBUFAD DS    1H         BUFFER ADDRESS
CHABUFAD DS    1H         BUFFER ADDRESS (CHAR)
MAXROW   DS    1H         WINDOW MAX ROW POS
MAXCOL   DS    1H         WINDOW MAX COLUMN POS
*
******** DCBS ************************************************
INDCB    DCB   LRECL=82,RECFM=F,MACRF=G,EODAD=ENDIN,
               DDNAME='MENUS2.DAT'
*INDCB    DCB   DDNAME=SYSUT1,MACRF=GM,DSORG=PS,
*               DEVD=DA,RECFM=FB,EODAD=END,LRECL=80,BLKSIZE=8560
*PRINTS   DCB   DDNAME=SYSUT2,RECFM=FBA,LRECL=81,DSORG=PS,
*               DEVD=DA,MACRF=PM,BLKSIZE=810
******** VARS ************************************************
         LTORG
**************************************************************
R1SAVE   DS    F          SAVE R1 FROM OPEN
**************************************************************
SVSLL    DS    F          PUSH RET ADDR
SLLRR    DS    9F         R1-R9 SAVE AREA
SVCLE    DS    F          PUSH RET ADDR
CLERR    DS    5F         R1-R5 SAVE AREA
SVPRI    DS    F          PUSH RET ADDR
SVREA    DS    F          PUSH RET ADDR
REARR    DS    F          R1 SAVE AREA
SVPRM    DS    F          PUSH RET ADDR
PRMRR    DS    3F         R1-R3 SAVE AREA
SVFIN    DS    F          PUSH RET ADDR
FINRR    DS    3F         R1-R3 SAVE AREA
SVLEV    DS    F          PUSH RET ADDR
LEVRR    DS    9F         R1-R9 SAVE AREA
SVTXH    DS    F          PUSH RET ADDR
TXHRR    DS    9F         R1-R9 SAVE AREA
SVTXV    DS    F          PUSH RET ADDR
TXVRR    DS    9F         R1-R9 SAVE AREA
SVGTF    DS    F          PUSH RET ADDR
GTFRR    DS    3F         R1-R3 SAVE AREA
SVLIS    DS    F          PUSH RET ADDR
LISRR    DS    3F         R1-R3 SAVE AREA
SVLFT    DS    F          PUSH RET ADDR
LFTRR    DS    9F         R1-R9 SAVE AREA
SVRIT    DS    F          PUSH RET ADDR
RITRR    DS    7F         R1-R7 PUSH REGS
SVSCA    DS    F          PUSH RET ADDR
SCARR    DS    9F         R1-R9 SAVE AREA
SVSCL    DS    F          PUSH RET ADDR
SCLRR    DS    9F         R1-R9 SAVE AREA
SVCHE    DS    F          PUSH RET ADDR
CHERR    DS    3F         R1-R3 SAVE AREA
SVSCC    DS    F          PUSH RET ADDR
SCCRR    DS    9F         R1-R9 SAVE AREA
SVSHR    DS    F          PUSH RET ADDR
SHRRR    DS    6F         R1-R6 PUSH REGS
SVTWE    DS    F          PUSH RET ADDR
TWERR    DS    2F         R1-R2 PUSH REGS
**************************************************************
SWLEVEL  DC    X'00'      LEVEL TABLE BUMPING SWITCH
SWLEVTX  DC    X'00'      JUST PASSED LEVEL PROCESSING SWITCH
MAXOPTLN DC    AL1(0)     MAXIMUM MENU OPTION LENGTH
MENOPTR  DC    AL1(0)     OPTIONS ROW BUFF
MENOPTR1 DC    AL1(0)     1ST OPTIONS ROW
MENOPTC  DC    AL1(0)     OPTIONS COLUMN BUFF
MENOPTC1 DC    AL1(0)     1ST OPTIONS COLUMN
OPTNCNT  DC    F'0'       MENU OPTIONS COUNT
HORZVERT DC    C' '       MOVE H=HORIZ V=VERT P=PROC S=SYS
**************************************************************
ERRSWIT  DC    X'00'      LEVEL PROCESSING ERROR SWITCH
*     1        LEVEL NUMBER NOT NUMERIC
*     2        LEVEL NUMBER OUT OF SEQENCE
*     4        COORDINATE NUMBER NOT NUMERIC
*     8        INVALID ROW
*    10        INVALID COLUMN
*    20        INVALID BOX ORIENTATION
*    40        INVALID TYPE
ERRSWIT1 DC    X'00'      TEXT PROCESSING ERROR SWITCH
SWNAMER  DC    X'00'    NO RECORD NAME SWITCH
ERRMSG   DC    CL47'-************ NO NAME RECORD FOUND ON FILE'
ERRMSG1  DC    CL47'-*** ERROR WHILE READING JOB FILE CONTROL BLOCK'
ERRMSG2  DC    CL47'-*** ERROR WHILE BUILDING TREE LEVEL TABLE *** '
RETCODE  DC    F'0'     PROGRAM RETURN CODE
COORDCMP DC    CL8' '   FIELD TO TEST COORDINATES TO BE ZERO
**************************************************************
         DC    C'HERE IS LINE'
LINE     DC    C' '       SPACE ONE AND PRINT
         DC    CL80' '    DATA FIELD
**************************************************************
IN1      DS    0CL256     (FIX FORMAT)
IN1COM   DS    C          COMMAND (@ OR T)
         DS    C
IN1TEX   DS    0CL78      FOR TEXT REFERENCE ONLY
IN1LEV   DS    CL20       MENU LEVEL
         DS    C
IN1TOP   DS    CL2        TOP ROW BOX COORDINATE
         DS    C
IN1LFT   DS    CL2        LEFT COLUMN BOX COORDINATE
         DS    C
IN1BOT   DS    CL2        BOTTOM ROW BOX COORDINATE
         DS    C
IN1RIT   DS    CL2        RIGHT COLUMN BOX COORDINATE
         DS    C
IN1TYP   DS    CL1        MENU TYPE OR PROCESS INDICATOR
         DS    C
IN1NAM   DS    CL8        PROCESS NAME IF IN1TYP=P OR S
         DS    C
IN1LIN   DS    C          HORIZONTAL LINE FOR HORIZONTAL MENUS
         DS    CL33       FILLER TO 80
         DS    CL176      FILLER TO 256 DUE TO DBC RECFM=T
**************************************************************
* INPUT FILE OPTIONS (@=LEVEL & BOX DATA) (T=MENU OPTIONS TEXT)
**************************************************************
* NAME=<MENU TREE NAME>
* C                      TR LC BR RC H=HORIZONTAL
* O                      OO EO OO IO V=VERTICAL
* M                      PW FL TW TL P=PROCESS    +---------------+
* N                      .. T. T. E. S=SYSTEM     |COMMANDS ALWAYS|
* D ------ LEVEL ------- .. .. M. .. . PROCES     |START ON COL 1 |
* @,01000000000000000000,02,04,05,23,P,PROC01     +---------------+
* T,PROCESO DE PRUEBA
* T,TEST PROCESS
* T,COMMAS ONLY TO MAKE IT EASY ON THE EYE
**************************************************************
FIRSTCU  DC    F'0'       INCERT CURSOR LOCATION AT CURSOR TABLE
FIRSTCU1 DC    F'0'       INCERT CURSOR LOCATION AT CURSOR TABLE
INRECCN  DC    F'0'       INPUT RECODR COUNT
LASTLEV  DC    X'00000000000000000000'  LAST LEVEL PROCESSED (SEQ CHK)
COMPLEV  DC    CL20'00000000000000000000' ZERO FIELD FOR NUM LEV TEST
LEVLEV1  DC    CL10' '                    LEVEL COMPARE ANDDING BUFF
LEVLEV2  DC    CL10' '                    LEVEL COMPARE ANDDING BUFF
LASTLVL  DC    F'0'   NON ZERO LEVEL CODE LEN
SAVELVL  DC    F'0'   NON ZERO LEVEL CODE LEN
**************************************************************
         DC    C' '                ERASE BYTE
HORIZCM  DC    CL80' '             HORIZONTAL OPTION TEXT BUFF
HORCURT  DC    100X'00'            HORIZONTAL CURSOR TABLE
HORCURTE EQU   *                   HORIZONTAL CURSOR TABLE END
         DC    X'00'               DELIMETER
*
**************************************************************
*     PROGRAM PARAMETER ENTRIES                              *
**************************************************************
         ENTRY SYSNAME
SYSNAME  EQU   *
         DC    CL8'INITIAL'  MENU TREE SYSTEM NAME
         DS    0D
         ENTRY TABSTADD
TABSTADD EQU   *
         DC    A(DYNTAB)    OUTPUT TABLE START ADDRESS
         ENTRY LEVSTADD
LEVSTADD EQU   *
         DC    A(DYNLEV)    LEVEL TABLE START ADDRESS
         ENTRY TREETPOI
TREETPOI EQU   *
         DC    A(TREETAB)   TREE TABLE POINTER TO MOVE SIDEWAYS
**************************************************************
LEVACADD DC    A(DYNLEV)    LEVEL TABLE ACTUAL ADDRESS
TABACADD DC    A(DYNTAB)    OUTPUT TABLE ACTUAL ADDRESS
WORKAEND DC    A(DATAEND)   END OF WORKAREA ADDRESS
PROCSYS  DC    A(SUBSYST)   NAME & TREE CURSOR LOCATION TABLE
**************************************************************
SUBSYSCN DC    F'0'   SYSTEM TABLE OCURRENCE COUNT
         DC    C'HERE IS SYSTEM TABLE'
SUBSYST  DC    CL8' ',10X'01' NAME, ADDR & TREE LOCATION
         DC    CL8' ',10X'00'          (20 LEVELS FOR NOW)
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
         DC    CL8' ',10X'00'
**************************************************************
         DC    C'HERE IS TREE TABLE'
         ENTRY TREETAB
TREETAB  EQU   *   20 X 10 TREE TABLE TO MOVE SIDEWAYS
         DC    X'01010000000000000000'
         DC    X'01020000000000000000'
         DC    X'01030000000000000000'
         DC    X'01040000000000000000'
         DC    X'01050000000000000000'
         DC    X'01060000000000000000'
         DC    X'01070000000000000000'
         DC    X'01080000000000000000'
         DC    X'01090000000000000000'
         DC    X'01100000000000000000'
         DC    X'01110000000000000000'
         DC    X'01120000000000000000'
         DC    X'01130000000000000000'
         DC    X'01140000000000000000'
         DC    X'01150000000000000000'
         DC    X'01160000000000000000'
         DC    X'01170000000000000000'
         DC    X'01180000000000000000'
         DC    X'01190000000000000000'
         DC    X'01200000000000000000'
         DC    X'00'
**************************************************************
         DC    C'HERE IS LEVEL TABLE'
         ENTRY MENUTAB
MENUTAB  EQU   *            MENU TABLE ENTRY POINT
DYNLEV   DS    CL4096       DYNAMIC LEVEL TABLE
         DC    C'HERE IS OTHER TABLES'
DYNTAB   DS    CL4096       DYNAMIC OUTPUT TABLE
         DS    CL4096       DYNAMIC OUTPUT TABLE
DATAEND  EQU   *
**************************************************************
*
LEV      DSECT              OUTPUT LEVEL TABLE ARGUMENT
LEVLEV   DS    CL10         LEVEL
LEVCURT  DS    AL4          CURSOR INPUT TEST TABLE ADDRESS
LEVMENU  DS    AL4          MENU OPTIONS TABLE ADDRESS
LEVLEN   DS    X            MENU OPTION OUTPUT COUNT
LEVMOP   DS    X            MENU OR PROCESS INDICATOR (OR SYSTEM)
LEVBOX   DS    AL4          BOX COORDIDATES
LEVCURO  DS    AL4          OUTPUT CURSOR TABLE LOCATIONS ADDR
         DS    AL4          4 MORE BYTES IF PROC NAME OR SYS MENU
LEVL     EQU   *-LEV        DSECT LENGTH
LEVLIM   DS    X            LEVEL TABLE LIMIT
*
CUR      DSECT              OUTPUT CURSOR TABLE ARGUMENT (LEN=7)
CURROW   DS    X            CURSOR ROW
CURCOL   DS    X            CURSOR COLUMN
CURATT   DS    X            CURSOR FIELD ATTRIBUTE
CURLEN   DS    X            LENGTH OF REST OF ARGUMENT (ALWAYS 3)
CURHOR   DS    0XL3         FOR HORIZONTAL IF 3 SPACES LEFT = X'114040'
CURFLD   DS    X            CURSOR LOCATION FIELD
CURCMD   DS    X            ATTRIBUTE COMMAND
CUREND   DS    X            END ATTRIBUTE
*
INCUR    DSECT              INCERT CURSOR TABLE ARGUMENT
INCURRW  DS    X            CURSOR ROW
INCURCL  DS    X            CURSOR COLUMN
INCURAT  DS    X            CURSOR FIELD ATTRIBUTE
INCURLN  DS    X            LENGTH OF REST OF ARGUMENT (ALWAYS 1)
INCURCM  DS    X            INCERT CURSOR COMMAND (13)
INCUREN  DS    X            CURSOR TABLE END INDICATOR
*
MEN      DSECT              OUTPUT MENU TABLE ARGUMENT
MENROW   DS    X            CURSOR ROW
MENCOL   DS    X            CURSOR COLUMN
MENATT   DS    X            CURSOR FIELD ATTRIBUTE
MENLEN   DS    X            LENGTH OF OPTION TEXT + X'1D60'
MENOPT   DS    C            START OF OPTION TEXT
*
         COPY \R42\CPY\EQUREGS.CPY
         END   VAL
